#summary Description of Java2Ecore syntax

= File structure =

= EPackage specification =

= Classifiers =
Java2Ecore supports all three types of classifiers:
 * _EClass_ which is represented by Java {{{class}}} or {{{interface}}} (see below)
{{{
interface MyInterface {
}
class First {
}
class Sample extends First implements MyInterface { // both extends and implements are supported
}
abstract class Abstract { // abstract modifier sets up EClass' abstract attribute
}
}}}
 * _EDataType_ which is represented by Java {{{class}}} with {{{@EDataType}}} annotation or just created automatically (see below)
{{{
@EDataType("java.awt.Point")
class Point {}
}}}
 * _EEnum_ which is represented by Java {{{enum}}}
{{{
enum Enum {
  A,
  B,
  C;
}
}}}

== Standard primitive types ==

ECore defines number of EDataTypes for general purposes: {{{EInt}}}, {{{EJavaObject}}} and so on.
To use those types in your model just use their Java analogs: {{{int}}} and {{{Object}}} for given example.

= Structural features =

Structural features are represented by felds. 
{{{
class A {
    int x;
    A y;
}
}}}
ERerferences are distiguished from EAttributes by type: if the type is EClass (see _Handling unknown types_ section) then the feature will be a reference otherwise it will be an attribute.

Above example is transformed to the following:

http://content.screencast.com/media/f65373b7-9f45-481e-ab41-a17993595cfc_2d2ecdec-33f4-4541-acd2-9ed52d228863_static_0_0_image.png

== Multiplicities ==

There are several wyas to denote feature's multiplicity:
 * Use Java array type
 * Use Java collections ({{{java.util.Collection}}} and it's descendants
 * Use MCollections (from {{{org.abreslav.java2ecore.multiplicities}}} package)
 * Use {{{@Bounds}}} annotation

=== Java arrays ===
You can denote a {{{0..*}}} multiplicity by using array type:
{{{
class A {
    int[] x; // produces an Attribute with lowerBound = 0 and upperBound = -1
}
}}}
Multiple feature is marked as _ordered_ and not _unique_.

*Note:* only one-dimension arrays are allowed and brackets must be specified after the type, not field name.

=== Java collections ===
You can use {{{java.util.Collection}}}, {{{java.util.Set}}} and {{{java.util.List}}} to denote the same {{{0..*}}} multiplicity. 

However, _ordered_ and _unique_ will differ:
{{{
class A {
    Collection<A> as; // 0..*, not ordered, not unique
    Set<String> strings; // 0..*, not ordered, unique
    List<Integer> ints; // 0..*, ordered, not unique (same as arrays)

}}}

=== MCollections ===
There are some auxilary classes defined in {{{org.abreslav.java2ecore.multiplicities}}} multiplicities package.

Main three of them are:
 * MCollection<T, L extends ILowerBound, U extends IUpperBound>
 * MSet<T, L extends ILowerBound, U extends IUpperBound>
 * MList<T, L extends ILowerBound, U extends IUpperBound>

These classes are analogous to Java collections but they allow to specify lowe and upper bounds in their {{{L}}} and {{{U}}} parameters.

Possible values are
 * {{{Infinity}}} - for infinite upper bound (-1)
 * {{{Unspecified}}} - for unspecified upper bound (-2)
 * {{{_<n>}}} where {{{<n>}}} is a non-negative integer
{{{
class A {
    MList<String, _1, _5> strings; // 1..5
}
}}}
  * {{{_0}}} cannot be specified as an upper bound and upper bound cannot be less than lower bound
  * Types {{{_0}}} through {{{_12}}} are defined in {{{org.abreslav.java2ecore.multiplicities}}}
  * If you need higher values you can create your own:
{{{
interface _239 extends ILowerBound, IUpperBound {
}
}}}

=== @Bounds ===
{{{
class A {
   @Bounds({5, 8})
   int x; // 5..8
}
}}}

== Other attributes of structural features ==
Some attributes are mapped from Java modifiers
 * {{{final}}} makes changeable false
 * {{{transient}}} makes transient true
 * {{{volatile}}} makes volatile true

You can specify default value by initializing a field:
{{{
class A {
    String s = "some"; // defaultValueLiteral = "some"
}
}}}

Other attributes are set by annotations:
 * @Bounds
   * mentioned above
 * @Containment
 * @DefaultValueLiteral
  * used when the type does not allow to initialize a field with an appropriate literal
 * @Derived
 * @ID
 * @Opposite
  * value() attribute specifies the name of the opposite feature
 * @Ordered
 * @ResolveProxies
 * @Unique
 * @Unsettable
 
= Operations =

Operations are defined just as in Java.
{{{
class A {
    void a(String x, int y) {
    }
}
}}}
Method body is always ignored.

To avoid writing stub code for methods returning values you can use astract mathods and to avoid making your class necessary abstract you can use _interface form of class_ (see next section).

= Inheritance =

As it is mentioned above Java-style inheritance (both {{{extends}}} and {{{implements}}}) is fully supported.
{{{
interface MyInterface {
}
class First {
}
class Sample extends First implements MyInterface { // both extends and implements are supported
}
abstract class Abstract { // abstract modifier sets up EClass' abstract attribute
}
}}}

But here we face a problem of multiple inheritance for classes being supported by ECore and not supported by Java.
Java2ECore provides a workaround which we call an _interface form of class_...

== Interface form of class ==

There's no multiple inheritance for classes in Java. But there is one for interfaces.

On the other hand you cannot declare non-final fields in interfaces in Java and final field has to be initialized which will set up defaultValueLiteral andis impossible for most types. And ECore support any structural features in interfaces.

So we provide the following: each interface (or class, to be consistent) can declare one inner-class, which holds all the parent's contents:
{{{
interface I {
class _{
    int x;
    I other;
}
}
}}}
In this example we created an EClass having {{{interface}}} attribute set to true and having one integer attribute and one reference of type {{{I}}}.

== Multiple inheritance for classes ==

To provide multiple inheritance for classes you can define them as Java interfaces supplying a {{{@Class}}} annotation which will tell Java2ECore not to set {{{interface}}} attribute to true.
{{{
@Class interface A {
class _{
   int x;
}
}
@Class interface B {
class _{
   A a;
}
}
@Class interface C extends A, B {
}
}}}

In this sample we created three _classes_, A, B and C, and C is a descendant of both A and B.

You still can specify {{{abstract}}} attribute along with {{{@Class}}} annotation to make your class abstract:
{{{
abstract @Class interface A {
class _{
   Object o;
}
}
}}}
= Handling unknown types =

= Generics =