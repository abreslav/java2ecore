#summary Description of Java2Ecore syntax

Note: all the following is about version 0.1. Current version is 0.2 and a description for it is being created.

= EPackage specification =
When you describe some Ecore model in a `*`.java file you define a top-level class to specify a root EPackage of the model, EPackages's contents (classifiers and subpackages) are denoted by nested Java types.

Use {{{@EPackage}}} annotation to denote a class that describes EPackage and set up nsPrefix and nsURI attributes.
{{{
@EPackage(
    nsPrefix="samples",   
    nsURI="http:///example.com/samples"
)  
public class samples {
    @EPackage(
        nsPrefix="subpackage",
        nsURI="http:///example.com/samples/subpackage"
    )
    class subpackage {
        // subpackage contents
    }

    // other root package contents
}
}}}
EPackage will have the same name as this class.

= Classifiers =
Java2Ecore supports all three types of classifiers:
 * _EClass_ which is represented by Java {{{class}}} or {{{interface}}} (see below)
{{{
@EPackage(
    nsPrefix="samples",   
    nsURI="http:///example.com/samples"
)  
public class samples {
    interface MyInterface {
    }
    class First {
    }
    class Sample extends First implements MyInterface { // both extends and implements are supported
    }
    abstract class Abstract { // abstract modifier sets up EClass' abstract attribute
    }
}
}}}
 * _EDataType_ which is represented by Java {{{class}}} with {{{@EDataType}}} annotation or just created automatically (see below)
{{{
@EDataType("java.awt.Point")
class Point {}
}}}
 * _EEnum_ which is represented by Java {{{enum}}}
{{{
enum Enum {
  A,
  B,
  C;
}
}}}

== Standard primitive types ==

Ecore defines number of EDataTypes for general purposes: {{{EInt}}}, {{{EJavaObject}}} and so on.
To use those types in your model just use their Java analogs: {{{int}}} and {{{Object}}} for given example.

= Structural features =

Structural features are represented by fields. 
{{{
class A {
    int x;
    A y;
}
}}}
ERerferences are distinguished from EAttributes by type: if the type is EClass (see _Handling unknown types_ section) then the feature will be a reference otherwise it will be an attribute.

Above example is transformed to the following:

http://content.screencast.com/media/f65373b7-9f45-481e-ab41-a17993595cfc_2d2ecdec-33f4-4541-acd2-9ed52d228863_static_0_0_image.png

== Multiplicities ==

There are several wyas to denote feature's multiplicity:
 * Use Java array type
 * Use Java collections ({{{java.util.Collection}}} and it's descendants
 * Use MCollections (from {{{org.abreslav.java2ecore.multiplicities}}} package)
 * Use {{{@Bounds}}} annotation

=== Java arrays ===
You can denote a {{{0..*}}} multiplicity by using array type:
{{{
class A {
    int[] x; // produces an Attribute with lowerBound = 0 and upperBound = -1
}
}}}
Multiple feature is marked as _ordered_ and not _unique_.

*Note:* only one-dimension arrays are allowed and brackets must be specified after the type, not field name.

=== Java collections ===
You can use {{{java.util.Collection}}}, {{{java.util.Set}}} and {{{java.util.List}}} to denote the same {{{0..*}}} multiplicity. 

However, _ordered_ and _unique_ will differ:
{{{
class A {
    Collection<A> as; // 0..*, not ordered, not unique
    Set<String> strings; // 0..*, not ordered, unique
    List<Integer> ints; // 0..*, ordered, not unique (same as arrays)

}}}

=== MCollections ===
There are some auxiliary classes defined in {{{org.abreslav.java2ecore.multiplicities}}} multiplicities package.

Main three of them are:
 * MCollection<T, L extends ILowerBound, U extends IUpperBound>
 * MSet<T, L extends ILowerBound, U extends IUpperBound>
 * MList<T, L extends ILowerBound, U extends IUpperBound>

These classes are analogous to Java collections but they allow to specify lower and upper bounds in their {{{L}}} and {{{U}}} parameters.

Possible values are
 * {{{Infinity}}} - for infinite upper bound (-1)
 * {{{Unspecified}}} - for unspecified upper bound (-2)
 * {{{_<n>}}} where {{{<n>}}} is a non-negative integer
{{{
class A {
    MList<String, _1, _5> strings; // 1..5
}
}}}
  * {{{_0}}} cannot be specified as an upper bound and upper bound cannot be less than lower bound
  * Types {{{_0}}} through {{{_12}}} are defined in {{{org.abreslav.java2ecore.multiplicities}}}
  * If you need higher values you can create your own:
{{{
interface _239 extends ILowerBound, IUpperBound {
}
}}}

=== @Bounds ===
{{{
class A {
   @Bounds({5, 8})
   int x; // 5..8
}
}}}

== Other attributes of structural features ==
Some attributes are mapped from Java modifiers
 * {{{final}}} makes changeable false
 * {{{transient}}} makes transient true
 * {{{volatile}}} makes volatile true

You can specify default value by initializing a field:
{{{
class A {
    String s = "some"; // defaultValueLiteral = "some"
}
}}}

Other attributes are set by annotations:
 * @Bounds
   * mentioned above
 * @Containment
 * @DefaultValueLiteral
  * used when the type does not allow to initialize a field with an appropriate literal
 * @Derived
 * @ID
 * @Opposite
  * value() attribute specifies the name of the opposite feature
 * @Ordered
 * @ResolveProxies
 * @Unique
 * @Unsettable
 
= Operations =

Operations are defined just as in Java.
{{{
class A {
    void a(String x, int y) {
    }
}
}}}
Method body is always ignored.

To avoid writing stub code for methods returning values you can use abstract methods and to avoid making your class necessary abstract you can use _interface form of class_ (see next section).

= Inheritance =

As it is mentioned above Java-style inheritance (both {{{extends}}} and {{{implements}}}) is fully supported.
{{{
interface MyInterface {
}
class First {
}
class Sample extends First implements MyInterface { // both extends and implements are supported
}
abstract class Abstract { // abstract modifier sets up EClass' abstract attribute
}
}}}

But here we face a problem of multiple inheritance for classes being supported by Ecore and not supported by Java.
Java2Ecore provides a workaround which we call an _interface form of class_...

== Interface form of class ==

There's no multiple inheritance for classes in Java. But there is one for interfaces.

On the other hand you cannot declare non-final fields in interfaces in Java and final field has to be initialized which will set up defaultValueLiteral and is impossible for most types. And Ecore supports any structural features in interfaces.

So we provide the following: each interface (or class, to be consistent) can declare one inner-class, which holds all the parent's contents:
{{{
interface I {
class _{
    int x;
    I other;
}
}
}}}
In this example we created an EClass having {{{interface}}} attribute set to true and having one integer attribute and one reference of type {{{I}}}.

== Multiple inheritance for classes ==

To provide multiple inheritance for classes you can define them as Java interfaces supplying a {{{@Class}}} annotation which will tell Java2Ecore not to set {{{interface}}} attribute to true.
{{{
@Class interface A {
class _{
   int x;
}
}
@Class interface B {
class _{
   A a;
}
}
@Class interface C extends A, B {
}
}}}

In this sample we created three _classes_, A, B and C, and C is a descendant of both A and B.

You still can specify {{{abstract}}} attribute along with {{{@Class}}} annotation to make your class abstract:
{{{
abstract @Class interface A {
class _{
   Object o;
}
}
}}}

= Handling unknown types =

When you define a type in your EPackage and then use it, there's no doubt about what happens then.

But what if you use some Java type not being declared in your package?
By default Java2Ecore creates a new EDataType with {{{instanceClassName}}} attribute set to fully-qualified name of unknown class.

The only exception is for unknown supertypes: such a type has to be EClass, not EDataType.
So, Java2Ecore creates EClass for such types assigning {{{instanceClassName}}} the same way.

= Generics =

Almost nothing to say: generics are fully supported :)...
 * Generic classes, interfaces and data types
  * even those created automatically for unknown types
 * Type parameters for methods
 * Upper and lower bounds (T extends Some, ? super T)
 * Several bounds on the same variable (T extends A & B)
 * Wildcards
  * with no bound (?)
  * with upper bound (? extends T)
  * with lower bound (? super T)

Did you ever know that Java itself supports all these things? :)

And a big sample:
{{{
class A<T, Q extends Comparable<? super T>> {

}
class B<E> {
abstract class _{
    A<E, Comparable<E>>;
    abstract <R, P> R doIt(Collection<? extends P & Serializable> objects) {};
}
}
class C extends B<String> {

}
}}}